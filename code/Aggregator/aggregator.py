#Aggregator
import os

from datetime import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from CGAN_Patterns.hyperparam import Hyperparam
TS=Hyperparam.TS_UNIFIED/60 #converted to minutes


currentDT = datetime.now()
trial = 'AGG' + str(currentDT.year) + str(currentDT.month) \
                     + str(currentDT.day) + str(currentDT.hour) + str(currentDT.minute)

if not os.path.exists("synth_output/aggregate/"+trial):
    os.makedirs("synth_output/aggregate/"+trial)
output_dir="synth_output/aggregate/"+trial

print('Enter the name of the folder (not full path) that contains synth_patterns.csv:') #Note: this file contains power samples in time steps e.g. steps of 3 mins if TS_UNIFIED=180
patterns_input_folder = input()
print('Enter the name of the folder (not full path) that contains synth_habbits.csv:')  #Note: this file contains data not impacted by TS_UNIFIED
habits_input_folder = input() 
print('Enter simulation quarter (1,2,3 or 4)')
sim_qtr= int(input())
assert 1<=sim_qtr<=4
sim_time=13 # each quarter is 13 weeks


patterns=pd.read_csv('synth_output/patterns/'+patterns_input_folder+'/synth_patterns_rounded.csv') #Get rounded power values (in Watts)
ampd_runs_per_week=pd.read_csv('synth_output/patterns/'+patterns_input_folder+'/ampd_runs_per_week.csv') #Get runs_per_week for each load. This is necessary to calculate the number of sample in a simulation
habbits=pd.read_csv('synth_output/habits/'+habits_input_folder+'/synth_gan_habits.csv') #Get habits generated by CGAN-Habits (For KDE-based habits, use the file synth_kde_habits)




def drop_duplicate(load_name, habbits):
    load_habbits=habbits[habbits['name'] == load_name]
    # load_patterns=patterns.loc[patterns['1'] == load_name]
    # load_habbits=load_habbits.reset_index(drop=True)
    # load_patterns=load_patterns.reset_index(drop=True)

    week=load_habbits['week'].values
    day=load_habbits['day'].values
    hour=load_habbits['hour'].values

    for i in range (len(load_habbits)):
        for j in range (i+1,len(load_habbits)):
            if week[j]==week[i] and day[j]==day[i] and abs(hour[j]-hour[i])<4:
                load_habbits=load_habbits.drop(load_habbits.index[i])
                #load_patterns=load_patterns.drop(load_patterns.index[i])
    return load_habbits#,load_patterns



#For every load, delete any overlapping habbits generated by GAN
loadslist=['HPE','DWE','CDE','FGE']
load_names=['Heat Pump', 'Dishwasher','Cloth Dryer','Fridge']


#segragate loads and drop overlapping habits
loads_patterns=[patterns[patterns['1']==x] for x in loadslist]
loads_habbits=[drop_duplicate(x, habbits) for x in loadslist]

def pick_qtr_habits(habits_df):
    if sim_qtr==1:
        qtr_habits=habits_df[(0<=habits_df['week']) & (habits_df['week']<=12)]
    elif sim_qtr==2:
        qtr_habits=habits_df[(12<habits_df['week']) & (habits_df['week']<=25)]
    elif sim_qtr==3:
        qtr_habits=habits_df[(25<habits_df['week']) & (habits_df['week']<=38)]
    else:
        qtr_habits=habits_df[(38<habits_df['week']) & (habits_df['week']<=51)]
    return qtr_habits


picked_habits=[pick_qtr_habits(loads_habbits[i]) for i in range(len(loadslist))]
no_drawn_samples=sim_time*ampd_runs_per_week.astype(int)
for i in range(len(loadslist)):
    if len(picked_habits[i])<no_drawn_samples.values[0][i]:
        print('Please increase the number of samples (SAMPLES) in habits hyperparamters and re-run generate_habits')

no_drawn_samples=no_drawn_samples.values.ravel()

#sample habits for simulation
sampled_habits=[]
sampled_patterns=[]
for i in range(len(loadslist)):
    no_samples=no_drawn_samples[i] if no_drawn_samples[i]<len(picked_habits[i]) else len(picked_habits[i])
    sampled_habits.append(picked_habits[i].sample(n=no_samples)) # You need to set random_state for repetitive outcome
    sampled_patterns.append(loads_patterns[i].sample(n=no_samples))


# i=0
# fp=sampled_patterns[i].iloc[:,2:].values[0]
# xp=np.arange(0,TS*len(fp),TS)
# x=np.arange(TS*len(xp))
# f=np.interp(x,xp,fp)
# fig, ax=plt.subplots(nrows=1,ncols=1)
# ax.plot(x,f, 'o',ls='-',ms=4,markevery=int(TS), label='Original Synthetic Pattern')
# ax.set_xlabel('Time (min)')
# ax.set_ylabel('Power (Watt)')
# plt.legend()
# plt.show()

def upsample_pattern(fp): #fp is the  synthetic matrix for all loads
    x_all=[]
    f_all=[]
    xp=np.arange(0,TS*fp.shape[1],TS)
    for i in range(fp.shape[0]):    
        x=np.arange(TS*len(xp))
        f=np.interp(x,xp,fp[i])
        x_all.append(x)
        f_all.append(f)
    x_all=np.array(x_all)
    f_all=np.array(f_all)
    return x_all,f_all

#combine patterns and habits
def get_load_power(patterns,habits,qtr): #patterns is passed in original sampling rate 
    x, patterns=upsample_pattern(patterns)
    event_time=habits[:,0]*7*24*60+habits[:,1]*24*60+habits[:,2]*60#Get time in minute when a cycle ends
    load_power=np.zeros(13*7*24*60) #load values across the quarter
    if qtr==1:
        offset=0
    elif qtr==2:
        offset=-13*7*24*60
    elif qtr==3:
        offset=-2*13*7*24*60
    else:
        offset=-3*13*7*24*60
    for i,event in enumerate(event_time):
        if (int(event+offset)-len(patterns[i]))<0: continue
        load_power[int(event+offset)-len(patterns[i]):int((event+offset))]=patterns[i] #pattern is projected ahead of event_time 
    return load_power

power=[]
for i in range(len(loadslist)):
    power.append(get_load_power(sampled_patterns[i].iloc[:,2:].values,sampled_habits[i].iloc[:,2:].values,sim_qtr))


# power=[get_load_power(sampled_patterns[i].iloc[:,2:].values,sampled_habits[i].iloc[:,2:].values) for i in range(len(loadslist))]

power=pd.DataFrame(power).T
power.columns=loadslist
power['AGG']=power.sum(axis=1)
power.to_csv(output_dir+'/agg_data_Q{}.csv'.format(sim_qtr), index=False)



#plt.style.use('seaborn-whitegrid')
plt.rcParams["figure.figsize"] = (8,4)
fig, ax=plt.subplots(nrows=1,ncols=1)
for i,load in enumerate(loadslist):
    y=power[load].values
    x=np.arange(len(y))
    ax.plot(x/60/24,y, label=load_names[i])
ax.legend(loc=6)
ax.set_xlabel('Time step (Day)')
ax.set_ylabel('Power (Watt)')
ax.set_title('Simulation for Q{}'.format(sim_qtr))  
plt.savefig(output_dir+'/sim_loads_Q{}.png'.format(sim_qtr)) 
plt.show()
