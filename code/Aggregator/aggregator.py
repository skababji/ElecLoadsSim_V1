#Aggregator
import os

from datetime import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt



currentDT = datetime.now()
trial = 'AGG' + str(currentDT.year) + str(currentDT.month) \
                     + str(currentDT.day) + str(currentDT.hour) + str(currentDT.minute)

if not os.path.exists("synth_output/aggregate/"+trial):
    os.makedirs("synth_output/aggregate/"+trial)
output_dir="synth_output/aggregate/"+trial

print('Enter the name of the folder (not full path) that contains synth_patterns.csv:')
patterns_input_folder = 'P_RESP_20223101356'# input()
print('Enter the name of the folder (not full path) that contains synth_habbits.csv:')
habits_input_folder = 'H_2022391411' #input()
print('Enter simulation quarter (1,2,3 or4)')
sim_qtr=1 #input()
sim_time=13 # each quarter is 13 weeks


patterns=pd.read_csv('synth_output/patterns/'+patterns_input_folder+'/synth_patterns_rounded.csv') #Get rounded power values (in Watts)
ampd_runs_per_week=pd.read_csv('synth_output/patterns/'+patterns_input_folder+'/ampd_runs_per_week.csv') #Get runs_per_week for each load. This is necessary to calculate the number of sample in a simulation
habbits=pd.read_csv('synth_output/habits/'+habits_input_folder+'/synth_gan_habits.csv') #Get habits generated by CGAN-Habits (For KDE-based habits, use the file synth_kde_habits)




def drop_duplicate(load_name, habbits):
    load_habbits=habbits[habbits['name'] == load_name]
    # load_patterns=patterns.loc[patterns['1'] == load_name]
    # load_habbits=load_habbits.reset_index(drop=True)
    # load_patterns=load_patterns.reset_index(drop=True)

    week=load_habbits['week'].values
    day=load_habbits['day'].values
    hour=load_habbits['hour'].values

    for i in range (len(load_habbits)):
        for j in range (i+1,len(load_habbits)):
            if week[j]==week[i] and day[j]==day[i] and abs(hour[j]-hour[i])<4:
                load_habbits=load_habbits.drop(load_habbits.index[i])
                #load_patterns=load_patterns.drop(load_patterns.index[i])
    return load_habbits#,load_patterns



#For every load, delete any overlapping habbits generated by GAN
loadslist=['HPE','DWE','CDE','FGE']


#segragate loads and drop overlapping habits
loads_patterns=[patterns[patterns['1']==x] for x in loadslist]
loads_habbits=[drop_duplicate(x, habbits) for x in loadslist]

def pick_qtr_habits(habits_df):
    if sim_qtr==1:
        qtr_habits=habits_df[(0<=habits_df['week']) & (habits_df['week']<=12)]
    elif sim_qtr==2:
        qtr_habits=habits_df[(12<habits_df['week']) & (habits_df['week']<=25)]
    elif sim_qtr==3:
        qtr_habits=habits_df[(25<habits_df['week']) & (habits_df['week']<=38)]
    else:
        qtr_habits=habits_df[(38<habits_df['week']) & (habits_df['week']<=51)]
    return qtr_habits


picked_habits=[pick_qtr_habits(loads_habbits[i]) for i in range(len(loadslist))]
no_drawn_samples=sim_time*ampd_runs_per_week.astype(int)
for i in range(len(loadslist)):
    if len(picked_habits[i])<no_drawn_samples.values[0][i]:
        print('Please increase the number of samples (SAMPLES) in habits hyperparamters and re-run generate_habits')

no_drawn_samples=no_drawn_samples.values.ravel()

#sample habits for simulation
sampled_habits=[picked_habits[i].sample(n=no_drawn_samples[i],random_state=24) for i in range(len(loadslist))]
sampled_patterns=[loads_patterns[i].sample(n=no_drawn_samples[i],random_state=24) for i in range(len(loadslist))]


#combine patterns and habits

def get_load_power(patterns,habits):
    event_time=habits[:,0]*7*24*60+habits[:,1]*24*60+habits[:,2]*60#Get time in minute when a cycle ends
    load_power=np.zeros(13*7*24*60) #load values across the quarter
    for i,event in enumerate(event_time):
        load_power[event-len(patterns[i]):event]=patterns[i] #pattern is projected ahead of event_time 
    return load_power

power=[get_load_power(sampled_patterns[i].iloc[:,2:].values,sampled_habits[i].iloc[:,2:].values) for i in range(len(loadslist))]

power=pd.DataFrame(power).T
power.columns=loadslist
power['AGG']=power.sum(axis=1)
power.to_csv(output_dir+'/agg_data.csv', index=False)



# plt.figure()
# plt.plot(indv_loads['time'],indv_loads['AGG'])
# plt.legend()
# plt.xlabel('min')
# plt.ylabel('Power (W)')
# plt.title('Synthesized Aggregated Load')

# plt.figure()
# #plt.plot(indv_loads['time'],indv_loads['AGG'])
# for idx,load in enumerate(loadslist):
#     plt.plot(indv_loads['time'],indv_loads[load],label=load)
# plt.legend()
# plt.xlabel('min')
# plt.ylabel('Power (W)')
# plt.title('Synthesized Indivisual Loads')


# plt.figure()
# for idx,load in enumerate(loadslist):
#     plt.subplot(5,2,idx+1)
#     plt.plot(indv_loads['time'],indv_loads[load],label=load)
#     plt.legend()


# from matplotlib.backends.backend_pdf import PdfPages

# def multipage(filename, figs=None, dpi=200):
#     pp = PdfPages(filename)
#     if figs is None:
#         figs = [plt.figure(n) for n in plt.get_fignums()]
#     for fig in figs:
#         fig.savefig(pp, format='pdf')
#     pp.close()

# multipage(output_dir+'/synth_figures.pdf')
