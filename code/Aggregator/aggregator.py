#Aggregator
import os

from datetime import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt



currentDT = datetime.now()
trial = 'AGG' + str(currentDT.year) + str(currentDT.month) \
                     + str(currentDT.day) + str(currentDT.hour) + str(currentDT.minute)

if not os.path.exists("synth_output/aggregate/"+trial):
    os.makedirs("synth_output/aggregate/"+trial)
output_dir="synth_output/aggregate/"+trial

print('Enter the name of the folder (not full path) that contains synth_patterns.csv:')
patterns_input_folder = input() #'P_RESP_20223101356'
print('Enter the name of the folder (not full path) that contains synth_habbits.csv:')
habits_input_folder =input() #'H_2022391411' 
print('Enter simulation quarter (1,2,3 or 4)')
sim_qtr=int(input())
assert 1<=sim_qtr<=4
sim_time=13 # each quarter is 13 weeks


patterns=pd.read_csv('synth_output/patterns/'+patterns_input_folder+'/synth_patterns_rounded.csv') #Get rounded power values (in Watts)
ampd_runs_per_week=pd.read_csv('synth_output/patterns/'+patterns_input_folder+'/ampd_runs_per_week.csv') #Get runs_per_week for each load. This is necessary to calculate the number of sample in a simulation
habbits=pd.read_csv('synth_output/habits/'+habits_input_folder+'/synth_gan_habits.csv') #Get habits generated by CGAN-Habits (For KDE-based habits, use the file synth_kde_habits)




def drop_duplicate(load_name, habbits):
    load_habbits=habbits[habbits['name'] == load_name]
    # load_patterns=patterns.loc[patterns['1'] == load_name]
    # load_habbits=load_habbits.reset_index(drop=True)
    # load_patterns=load_patterns.reset_index(drop=True)

    week=load_habbits['week'].values
    day=load_habbits['day'].values
    hour=load_habbits['hour'].values

    for i in range (len(load_habbits)):
        for j in range (i+1,len(load_habbits)):
            if week[j]==week[i] and day[j]==day[i] and abs(hour[j]-hour[i])<4:
                load_habbits=load_habbits.drop(load_habbits.index[i])
                #load_patterns=load_patterns.drop(load_patterns.index[i])
    return load_habbits#,load_patterns



#For every load, delete any overlapping habbits generated by GAN
loadslist=['HPE','DWE','CDE','FGE']


#segragate loads and drop overlapping habits
loads_patterns=[patterns[patterns['1']==x] for x in loadslist]
loads_habbits=[drop_duplicate(x, habbits) for x in loadslist]

def pick_qtr_habits(habits_df):
    if sim_qtr==1:
        qtr_habits=habits_df[(0<=habits_df['week']) & (habits_df['week']<=12)]
    elif sim_qtr==2:
        qtr_habits=habits_df[(12<habits_df['week']) & (habits_df['week']<=25)]
    elif sim_qtr==3:
        qtr_habits=habits_df[(25<habits_df['week']) & (habits_df['week']<=38)]
    else:
        qtr_habits=habits_df[(38<habits_df['week']) & (habits_df['week']<=51)]
    return qtr_habits


picked_habits=[pick_qtr_habits(loads_habbits[i]) for i in range(len(loadslist))]
no_drawn_samples=sim_time*ampd_runs_per_week.astype(int)
for i in range(len(loadslist)):
    if len(picked_habits[i])<no_drawn_samples.values[0][i]:
        print('Please increase the number of samples (SAMPLES) in habits hyperparamters and re-run generate_habits')

no_drawn_samples=no_drawn_samples.values.ravel()

#sample habits for simulation

sampled_habits=[]
sampled_patterns=[]
for i in range(len(loadslist)):
    no_samples=no_drawn_samples[i] if no_drawn_samples[i]<len(picked_habits[i]) else len(picked_habits[i])
    sampled_habits.append(picked_habits[i].sample(n=no_samples)) # You need to set random_state for repetitive outcome
    sampled_patterns.append(loads_patterns[i].sample(n=no_samples))



#combine patterns and habits

def get_load_power(patterns,habits,qtr):
    event_time=habits[:,0]*7*24*60+habits[:,1]*24*60+habits[:,2]*60#Get time in minute when a cycle ends
    load_power=np.zeros(13*7*24*60) #load values across the quarter
    load_power=load_power[::3] #downsample by unified sampling rate
    if qtr==1:
        offset=0
    elif qtr==2:
        offset=-13*7*24*60
    elif qtr==3:
        offset=-2*13*7*24*60
    else:
        offset=-3*13*7*24*60
    for i,event in enumerate(event_time):
        if (int((event+offset)/3)-len(patterns[i]))<0: continue
        load_power[int((event+offset)/3)-len(patterns[i]):int((event+offset)/3)]=patterns[i] #pattern is projected ahead of event_time 
    return load_power

power=[]
for i in range(len(loadslist)):
    power.append(get_load_power(sampled_patterns[i].iloc[:,2:].values,sampled_habits[i].iloc[:,2:].values,sim_qtr))


# power=[get_load_power(sampled_patterns[i].iloc[:,2:].values,sampled_habits[i].iloc[:,2:].values) for i in range(len(loadslist))]

power=pd.DataFrame(power).T
power.columns=loadslist
power['AGG']=power.sum(axis=1)
power.to_csv(output_dir+'/agg_data_Q{}.csv'.format(sim_qtr), index=False)



plt.style.use('seaborn-whitegrid')
plt.rcParams["figure.figsize"] = (8,4)
fig, ax=plt.subplots(nrows=1,ncols=1)
for load in loadslist:
    ax.plot(power[load].values[::3], label=load)
ax.legend(title='Load')
ax.set_xlabel('Time step (3 mins)')
ax.set_ylabel('Power (Watts)')
ax.set_title('Simulation for Q{}'.format(sim_qtr))  
plt.savefig(output_dir+'/sim_loads_Q{}.png'.format(sim_qtr)) 
plt.show()
